use ndarray::{Array1, Array2};

pub struct StandardScaler {
    mean: Array1<f64>,
    scale: Array1<f64>,
}

impl StandardScaler {
    pub fn new() -> Self {
        // StandardScaler parameters from your Python model
        let mean: Vec<f64> = vec![-99.71553946950553, 85.01086463613808, 2.582826132618837, 25.17494681255883, 1.897743785418031, 5.712565279405987, -2.826423296575777, -3.053434632340388, 0.6780300988388179, 0.976142094174017, 1.4389117834622305, 4.2949304079298045, 0.9539592882198435, 73.38739428616785, 38.064140205513, 26.96249917332129, 21.102822246554272, 16.112252603278115, 13.220158998590009, 12.43175903270366, 13.038788263490538, 10.572050499695319, 10.008414198632961, 8.728649169970074, 7.902415367455026, 7.653465449377711];
        
        let scale: Vec<f64> = vec![2.7034344275090763, 19.99776134412907, 15.596883901776426, 13.019120298401143, 10.107216611423844, 8.293919970363836, 7.814586671361422, 6.99566170431455, 6.019241591984569, 5.358899336595711, 5.5237037846190695, 4.751917089751102, 4.774291290658192, 25.76816944124238, 13.522319941535299, 9.278159472690293, 6.434358952435951, 5.765467217935525, 4.129160010955821, 3.7621787723457905, 4.186186858077365, 3.1141115423346415, 3.0027973274476647, 2.4573741449214754, 2.1745987670980536, 2.1852869890916753];

        Self {
            mean: Array1::from(mean),
            scale: Array1::from(scale),
        }
    }

    pub fn transform(&self, features: &Array2<f64>) -> Array2<f64> {
        let mut scaled = features.clone();
        
        for mut row in scaled.rows_mut() {
            for (i, val) in row.iter_mut().enumerate() {
                *val = (*val - self.mean[i]) / self.scale[i];
            }
        }
        
        scaled
    }

    pub fn transform_single(&self, features: &Array1<f64>) -> Array1<f64> {
        let mut scaled = features.clone();
        
        for (i, val) in scaled.iter_mut().enumerate() {
            *val = (*val - self.mean[i]) / self.scale[i];
        }
        
        scaled
    }
}
